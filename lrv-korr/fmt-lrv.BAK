
                    ;;;;;;;; Risc-V Instruction formats ;;;;;;;;

(in-package "RVASM")



        ;;;; compressed formats ;;;;

;; cr - Compressed Register
(defun creg (rd rs1 op4 op2)
  ;;(emit-jait
  (build-expr-code '(4 5 5 2) op4 (regno rd) (regno rs1) op2)
  ;)
  )

;; This builds a generic function with methods for integers and promises/labels
(defmacro define-immediate-type (name param-list &body body )
   `(defgeneric ,name ,param-list
     (:method ((,(car param-list) integer) ,@(cdr param-list))
                         ,@body )
     (:method ((,(car param-list) promise) ,@(cdr param-list))
          (delay ,(symbol-name name) ,(list (car param-list)) (,name ,@param-list) )))
   )


;; ci  - Compressed Immediate
;;(defgeneric cimm (imm6 rd op1 op2)
(define-immediate-type cimm (imm6 rd op1 op2)
   (if (immp imm6 6 )
      ;; ;;(emit-jait
        (build-expr-code '(3 1 5 5 2) op1 (bits imm 5) (regno rd) (bits imm 4 0)
                                      op2);)
      (rv-error "Commpressed immediate value out of range"))
   )

;; ciw - Compressed Wide Immediate
;;(defgeneric ciwid (imm8 rd op1 op2)
(define-immediate-type ciwid (imm8 rd op1 op2)
   (if (immp imm8 8)
      ;; ;;(emit-jait
        (build-expr-code '(3 2 4 1 1 3 2) op1 (bits imm8 7 6) (bits imm8 5 2)
                                          (bits imm8 0 ) (bits imm8 1)
                                          (cregno rd) op2);)
      (rv-error "Compressed wide immediate value out of range"))
   )

;; cis - Compressed Immediate Small
;;(defgeneric cismal (imm6 rd op1 op2 op3)
(define-immediate-type cismal (imm6 rd op1 op2 op3)
   (if (immp imm6 6)
      ;; ;;(emit-jait
        (build-expr-code '(3 1 2 3 5 2) op1 (bits imm 5) op2 (cregno rd)
                                        (bits imm 4 0) op3);)
      (rv-error "Compressed small immediate value out of range"))
   )


;; cl - Compressed Load
;;(defgeneric cload (imm5 rd rs1 op1 op2)
(define-immediate-type cload (imm5 rd rs1 op1 op2)
   (if (immp imm5 5)
      ;;(emit-jait
        (build-expr-code '(3 3 3 2 3 2) op1 (bits imm5 2 0) (cregno rs1)
                                        (bits imm5 4 3) (cregno rd) op2);)
      (rv-error "Compressed load mmediate value out of range"))
   )

;; cs - Compressed Store
;;(defgeneric cstore (imm5 rs1 rs2 op1 op2)
(define-immediate-type cstore (imm5 rs1 rs2 op1 op2)
   (if (immp imm5 5)
      ;;(emit-jait
        (build-expr-code '(3 3 3 1 1 3 2) op1 (bits imm5 3 1) (cregno rs1)
                                          (bits imm5 0) (bits imm5 4) (cregno rd) op2);)
      (rv-error "Compressed store mmediate value out of range"))
   )

;; css - Compressed Stack Relative Store
;; (defgeneric cstst (imm6 rs2 op1 op2)
(define-immediate-type cstst (imm6 rs2 op1 op2)
   (if (immp imm6 6)
      ;;(emit-jait
        (build-expr-code '(3 4 2 5 2) op1 (bits imm6 3 0) (bits imm6 5 4)
                                       (regno rs2) op2);)
      (rv-error "Compressed Stack relative store immediate value out of range"))
   )

;; ca - Compressed Arithmetic
(defun carith (op3 op1 op2 rd op2b rs2)
  ;; (if (and (cregp rd) (cregp rs2))
      ;;(emit-jait
        (build-expr-code '(3 1 2 3 2 3 2) op3 op1 op2 (cregno rd) op2b
                                          (cregno rs2) 1);)
      ;; (rv-error "C won't fit"))
      )

;; cj - Compressed Jump
;;(defgeneric cjump (imm11 funct3 op)
(define-immediate-type cjump (ofst funct3 op)
    (cond ((not (immp ofst 11))
           (rv-error "cjump: immediate value out of range" addr))
          ((not (zerop (logand ofst #x1)))
           (rv-error "cjump: immediate value should be multiple of 2" addr))
    ;;(emit-jait
          (t
           (build-expr-code '(3 1 1 2 1 1 1 3 1 2)
                            funct3 (bits ofst 11) (bits ofst 4) (bits ofst 9 8)
                                   (bits ofst 10) (bits ofst 6) (bits ofst 7)
                                   (bits ofst 3 1)(bits ofst 5) op);)
    ;; (rv-error "Immediate value out of range")
    ))
   )

;; cb - Compressed Branch
;;(defgeneric cbranch (imm8 rs1 funct3 op)
(define-immediate-type cbranch (imm8 rs1 funct3 op)
   (if (imm? imm8 8)
      ;;(emit-jait
        (build-expr-code '(3 1 2 3 2 2 1 2)
             funct3 (bits imm8 7) (bits imm8 3 2) (cregno rs1) (bits imm8 6 5)
             (bits imm8 1 0) (bits imm8 4) op);)
      (rv-error "immediate value out of range"))
   )


;; (defun cimm6 (rd imm op1 op2)
;;   (emit '(3 1 5 5 2) op1 (bits imm 5) (regno rd) (bits imm 4 0) op2))

;; (defun cimm6* (rd imm op1 op2 op3)
;;   (emit '(3 1 2 3 5 2) op1 (bits imm 5) op2 (cregno rd) (bits imm 4 0) op3))


;; (defun cimmed (imm12 rs1 funct3 rd op)
;;   (emit* '(12 5 3 5 7) imm12 (regno rs1) funct3 (regno rd) op))

;; (defun cregister (op3 op1 op2 rd op2b rs2)
;;   (cond
;;    ((and (cregp rd) (cregp rs2))
;;     (emit '(3 1 2 3 2 3 2) op3 op1 op2 (cregno rd) op2b (cregno rs2) 1))
;;    (t (error* "C won't fit"))))

        ;;;; base formats ;;;;

(defun register (funct7 rs2 rs1 funct3 rd op)
  ;;(emit-vait
    (build-expr-code '(7 5 5 3 5 7) funct7 (regno rs2) (regno rs1) funct3
                                    (regno rd) op));)

;; (defun register (funct7 rs2 rs1 funct3 rd op)
  ;; (emit* '(7 5 5 3 5 7) funct7 (regno rs2) (regno rs1) funct3 (regno rd) op))

;;(defgeneric immed (imm12 rs1 funct3 rd op)
(define-immediate-type immed (imm12 rs1 funct3 rd op)
   (if (immp imm12 12)
      ;;(emit-vait
       (build-expr-code '(12 5 3 5 7) imm12 ;(logand imm12 #xfff)
                                      (regno rs1) funct3 (regno rd) op)
       ;; )
      (rv-error "Immediate value out of range"))
   )

;; (defun immed (imm12 rs1 funct3 rd op)
;;   (cond
;;    ((immp imm12 12)
;;     (emit* '(12 5 3 5 7) (logand imm12 #xfff) (regno rs1) funct3 (regno rd) op))
;;    (t
;;     (error* "Immediate value out of range"))))

;;(defgeneric branch (imm12 rs2 rs1 funct3 op)
(define-immediate-type branch (imm rs2 rs1 funct3 op)
  (let ((off (offset imm)))
    (cond ((not (immp off 13)) (rv-error "Branch immediate value out of range"))
          ((not (zerop (logand off 1)))
           (rv-error "Branch immediate value not properly aligned"))
          (t
   ;; (if (immp imm12 12)
      ;; (let ((off (offset imm12)))
         ;; (emit-vait
           (build-expr-code '(1 6 5 5 3 4 1 7)
              (bits off 12) (bits off 10 5) (regno rs2)
              (regno rs1) funct3 (bits off 4 1) (bits off 11) op)
            )
      ;)
      ;; (rv-error "Branch immediate value out of range"))
        ;; )
  )))

;; (defun branch (imm12 rs2 rs1 funct3 funct7)
;;   (let ((off (offset imm12)))
;;     (emit* '(1 6 5 5 3 4 1 7)
;;            (bits off 12) (bits off 10 5) (regno rs2)
;;            (regno rs1) funct3 (bits off 4 1) (bits off 11) funct7)))

;;(defgeneric jump (imm20 rd)
(define-immediate-type jump (imm rd)
  (let ((off (offset imm)))
    (cond ((not (immp off 21)) (rv-error "Jump immediate value out of range"))
          ((not (zerop (logand off 1)))
           (rv-error "Jump immediate value not properly aligned"))
   ;; (if (cl:and (immp imm20 21) (zerop (logand imm21 1)))
          (t
      ;;(emit-vait
           (build-expr-code '(1 10 1 8 5 7)  (bits off 20) (bits off 10 1)
                                             (bits off 11) (bits off 19 12)
                                             (regno rd) #x6f)
        ;)
      ;; (rv-error "Jump immediate value out of range no good")
           )
          ))
   )


;; (defun jump (imm20 imm10-1 imm11 imm19-12 rd op)
;;   (emit* '(1 10 1 8 5 7) imm20 imm10-1 imm11 imm19-12 rd op))

;;(defgeneric store (imm12 src base funct3)
(define-immediate-type store (imm12 src base funct3)
   (if (immp imm12 12)
      ;;(emit-vait
        (build-expr-code '(7 5 5 3 5 7) (bits imm 11 5) (regno src) (regno base)
                                        funct3 (bits imm 4 0) #x23)
                                        ;)
      (rv-error "Store immediate value out of range"))
   )


(define-immediate-type upperimm (imm32 rd)
  (cond ((not (immp imm32 32)) (rv-error "Upper immediate value out of range"))
        ((not (zerop (logand imm32 #xfff )))
         (rv-error "Upper immediate value not properly aligned"))
  ;; (if (cl:and (immp imm32 32) (zerop (logand imm #xfff)))
        (t
          (build-expr-code '(20 5 7) (bits imm32 31 12) (regno rd) #x37)
      ;; (rv-error "Upper immediate value out of range"))
      ;; (rv-error "Upper immediate value no good"))
          ))
  )
        ;;;; multiply formats ;;;;

(defun muldiv (rs2 rs1 funct3 rd funct7)
  ;;(emit-vait
    (build-expr-code '(7 5 5 3 5 7) 1 (regno rs2) (regno rs1) funct3
                                      (regno rd) funct7));)

;

;; (defmacro define-c-immediate-type (name (param-list) &body body )
;; `(progn
;;    (degeneric ,name ,(pram-list)
;;               (:method ((,car ,(pram-list) ,@(cdr ,@(pram-list))
;;                          ,@body )))
;;               (:method ((,car ,(pram-list) ,@(cdr ,@(pram-list))
;;                               (delay (symbol-name name) (pram-list) (name (param-list) )))
;;                         )
;;                 )
;;               )
;;    )
;;   )
;; (defmacro define-c-immediate-type (name param-list &body body )
;; ;; `(progn
;;    `(defgeneric ,name ,param-list
;;      ;; ,@body
;;      (:method ((,(car param-list) integer) ,@(cdr param-list))
;;                          ,body );))
;;      (:method ((,(car param-list) promise) ,@(cdr param-list))
;;           (delay ,(symbol-name name) ,param-list (,name ,param-list) )))
;;      ;; (:method ((,car ,(pram-list) ,@(cdr ,@(pram-list))
;;                               ;; (delay (symbol-name name) (pram-list) (name (param-list) )))
;;                         ;; )
;;                 ;; )
;;               ;; )
;;    )
;; (defmacro define-c-immediate-type (name param-list &body body )
;; ;; `(progn
;;    `(defgeneric ,name ,param-list
;;      ;; ,@body
;;      (:method ((,(car param-list) integer) ,@(cdr param-list))
;;                          ,@body );))
;;      (:method ((,(car param-list) promise) ,@(cdr param-list))
;;           (delay ,(symbol-name name) ,(list (car param-list)) (,name ,param-list) )))
;;      ;; (:method ((,car ,(pram-list) ,@(cdr ,@(pram-list))
;;                               ;; (delay (symbol-name name) (pram-list) (name (param-list) )))
;;                         ;; )
;;                 ;; )
;;               ;; )
;;    )
